#include<iostream>
#include<conio.h>
#include "MyArrow.h"
#include<time.h>

using namespace std;

void foo(MyArrow A) {
	A.Show();
}

ostream & operator<<(ostream & os, const MyArrow & A)
{
	for (int i = 0; i < A.SIZE; i++) os << A.arr[i] << " ";
	return os;
}


MyArrow CreateMyArrow(MyArrow& A)
{
	MyArrow TMP(A);
	return TMP;
}

int main(){
	/*HW3 «адание 1. Ќапишите класс MyArray с динамическим выделением пам€ти дл€
		хранени€ значений целого типа. –еализуйте все необходимые методы: 
		
		конструктор по умолчанию, 
		конструктор с параметрами, 
		конструктор копировани€, 
		деструктор.
		
		ѕерегрузите операции: [], =, <<. 
		Ќапишите метод, возвращающий среднее значение
		массива. 
		
		ќбеспечьте возможность подсчета количества созданных объектов класса.*/
	
	srand(time(NULL));


	//MyArrow A;
	//A.Show();
	//MyArrow B(5);
	//B.Show();
	//cout << "count: "<< MyArrow::count << endl;	//подсчет объектов
	//foo(B);	//проверка конструктора копий(через дружественную функцию)
	//cout << "==============================";
	//A = B;	//работа оператора =
	//A.Show();
	//cout << "A[2] = " << A[2] <<endl; //работает оператор []
	//cout << "==============================\n";
	//cout << A;	//перегрузка оператора ostream <<
	//cout << "==============================\n";
	//cout << A.calcAVG();	//среднее значение массива


	/*HW4 «адание 2. ƒобавить в уже существующий класс MyArray конструктор переноса,
		оператор присваивани€ переноса.*/

	MyArrow A(5);
	cout << "A: ";
	A.Show();
	MyArrow B(A);	//работает конструктор переноса, строка 14 в MyArrow.h
	cout << "B: ";
	B.Show();
	cout << "=====================================\n";
	MyArrow C;
	C = CreateMyArrow(A);	//после создани€ объекта срабатывает оператор присваивани€ переноса, строка 17 в MyArrow.h
	C.Show();
	A = C;		//а здесь срабатывает обычный оператор присваивани€
	cout << "A: ";
	A.Show();
	

	







	_getch();
	return 0;
}